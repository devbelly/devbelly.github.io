---
title: "Introduction to Operating Systems"
date: 2023-08-17T22:46:12+09:00
draft: false
toc: true
comments: true
tags:
  - os
---

컴퓨터에서는 일반적으로 여러 프로그램들이 실행됩니다. 한정적인 물리적 리소스를 통해 많은 프로그램들을 실행하려면 어떻게 할까요? 운영체제는 이 문제를 해결하기 위해 가상화라는 기술을 사용합니다. 이를 통해 운영체제는 여러 프로그램들을 실행하고 메모리를 공유하며 장치에 쉽게 접근할 수 있도록 해줍니다. 

## Virtualizing The CPU

<img width="100%" alt="image" src="https://github.com/devbelly/image-issue/assets/67682840/f4af59a1-8424-43e9-a96f-4cebe4cfeb62">

`argc` 값을 확인하여 두번째 파라미터에 입력된 값을 1초 간격으로 출력하는 프로그램입니다. `"usage: cpu <string>\n"` 부분을 통해 오브젝트 파일의 이름은 `cpu`임을 추측할 수 있습니다. 이 프로그램을 백그라운드에서 동시에 4개를 실행해보겠습니다.

<img alt="image" src="https://github.com/devbelly/image-issue/assets/67682840/edbad6fa-b78b-409b-9e49-4be195c6cc0f">

`&` 를 통해 백그라운드에서 총 4개의 프로세스가 생성된 것을 확인할 수 있습니다. 프로세스를 식별하기 위한 pid도 확인할 수 있습니다.

컴퓨터의 CPU는 한정적인 자원입니다. 서버는 수십, 수천개를 갖고 있지만 일반적인 노트북은 그렇게 갖고 있지 못합니다. 그럼에도 CPU보다 많은 수의 프로그램을 실행할 수 있는데 그 이유는 CPU의 가상화에 있습니다. 물리적으로는 하나의 CPU지만 현상적으로는 무한대처럼 보이게 합니다.

<img alt="image" src="https://github.com/devbelly/image-issue/assets/67682840/44dd9b12-89a8-4878-89c8-d66b4a927699">

## Virtualizing The Memroy

메모리는 프로그램이 수행되는 동안 CPU에 의해 처리되는 데이터를 저장하거나 CPU가 언제든 그 데이터에 엑세스 할 수 있게 하는 역할을 합니다. 그리고 프로그램의 각 명령어도 메모리에 있으므로 명령어를 가져올때마다 메모리에 엑세스하게 됩니다.

<img  alt="image" src="https://github.com/devbelly/image-issue/assets/67682840/462043e6-965e-4367-bab5-854dec4edf32">

프로그램을 살펴보면 4바이트의 메모리를 할당받아 할당받은 주소를 출력한 후 1초 간격으로 해당 주소로 접근 해 1씩 증가하는 프로그램입니다. 아래는 위 프로그램을 그림으로 표현한 것입니다. 

<img  alt="image" src="https://github.com/devbelly/image-issue/assets/67682840/7ba8fe64-86ae-4476-ba9a-bf72f24b79a8">

이 프로그램을 앰퍼샌드(`&`)를 통해 동시에 두 개를 실행해보겠습니다. 두 개를 실행했으므로 두 프로그램이 협력해서 동일한 물리적 메모리에 접근하여 숫자를 증가시킬까요?

<img alt="image" src="https://github.com/devbelly/image-issue/assets/67682840/ea0f8021-797d-4165-9b61-fe0db022700b">

실행결과는 예상과 다른 것을 확인할 수 있습니다. 서로 다른 프로세스가 동일한 주소(`0x200000`)를 가리키고 있지만 서로 독립적인 값을 업데이트 하고 있습니다. 즉, 프로그램이 실행되면 프로세스가 생성되고 프로세스가 사용하는 메모리는 물리적인 메모리가 아닌 가상화된 메모리임을 알 수 있습니다. 각 프로세스마다 갖는 가상화된 메모리를 Address Space라고 합니다. 

![[Pasted image 20230818142650.png]]

두개를 실행한 화면. 두개의 프로세스가 임의의 순서대로 임의의 순서대로 출력.
24113, 24114 다른 프로세스도 똑같은 주소를 가리키고 있지만 얼핏보면 두 프로세스가 협력해서 p가 가리키는 곳을 증가시키는 걸로 생각.

실행결과는 각자 *p를 증가시키는 것을 확인할 수 있따. 서로 독립된다.

추정가능한점
- 프로그램이 실행될 때 프로세스가 생성.
- 프로세스가 사용하는 메모리 라는 것이 물리적잉ㄴ 메모리가 아닌 가상화된 메모리이다.

가상화된 주소 공간을 address space라고 한다.

![[Pasted image 20230818143200.png]]

즉 메모리의 가상화란 프로세스별로 독립된 메모리를 사용하는 것을 의미한다.

주소공간을 통해 서로 독립적인 메모리 공간을 갖는다.


---
2.3 councurrency

![[Pasted image 20230818143441.png]]

전역변수이므로 메모리에 한 곳에 배치된다.
즉 프로그램이 실행되는 프로세스 안에서 카운터는 유일하게 한 군데에서만 존재 /루프도 하나만 존재.

둘의 차이점은 초기화가 되어잇나 안되어있나 차이
loops는 하드디스크에 있는 프로그램이 실행되기 위해 메모리에 올라 올 때 자동으로 0으로 초기화가 되긴한다.  

초기값에 따라 실행파일을 만들때는 다른 구조

카운터는 초기값이 있으므로 실행파일에 포함되고.. 포함되는 ㄴ것들
	- 초기값이 있는  전역변수
	- 초기값이 있는 static var
	- 프로그램 코드

반면에 루프는 초기값이 없어 실행파일에 속하지는 않고 loops 만큼의 크기의 공간을 0으로 만들어준다
- 이를 BSS 영역이라고 한다. (아마 통으로 0으로 만드는거 같다.)

i는 지역변수. 스택에 자리를 잡음.
반면에 전역변수는 프로그램이 실행을 위해 메모리에 탑 재 될때 생성될때 프로그램 종료시 같이 메모리에서 사라지는 구조이다.

메인 함수가 하는 일은 두번째 아규먼트를 받아서 해당 숫자만큼 카운터를 증가시키는 일을 한다.

 `Pthread_Create`를 통해서 쓰레드를 생성한다. 두번재와 네번째 NULL값은 스택 크기를 자동으로 설정하게 끔한다.
세번째 파라미터는 새로운 쓰레드의 시작 지점을 워커로 한다. 라는 의미이다.


코드(text) - 프로그램을 컴파일해서 얻은 기계어 코드
data - 인스턴스가 하나인 것들 
	- 데이터는 두가지로 나뉜다.
	- 초기값이 있는 전역변수
	- 초기값이 없는 전역번수
	- 


이를 구분하는 이유는 초기값이 있는 데이터 영역은 텍스트 부분과 함께 묶여 하드디스크의 실행파일로 저장된다.
![[Pasted image 20230819010131.png]]

즉 교재에서 threads 라는 실행파일에 포함된 것은 코드영역 + counter 변수이다.  

실행파일에서 BSS 영역의 크기를 기록해놓고 있다. 
일괄적으로 null로 만들어 준다.

![[Pasted image 20230819010517.png]]

이 과정은 로딩할때 벌어진다.

그다음은 Heap과 Stack이 있다.

![[Pasted image 20230819011015.png]]

하지만 쓰레드가 두개일 때는 쓰레드마다 스택을 갖는데 이를 execution stack이라고 한다.
이를 통해 알 수 있는 것은 쓰레드가 2개일때는 코드, 데이터, 힙을 공유하고 스택은 각자 갖는 구조이다.

쓰레드를 만든다 라는 것은 무슨의미일까?  여러가지 일을 하게 되는데
- 1. 스택 크기를 얼마로 할까? 
- 2. 워커라는 함수를 실행하기 위한 activation record를 저장한다.
	- 지역변수, 파라미터 등을 저장하기 위한 블록이다
- ![[Pasted image 20230819011504.png]]

각자 루프를 돌며 counter를 증가시킨다.(협력)

![[Pasted image 20230819011729.png]]



![[Pasted image 20230819011818.png]]

숫자를 크게 하면 우리가 예상하는 값과 다르게 나온다. 비결정적인 모습

----
volatile은 뭘까? 
카운터를 반드시 메모리에 할당하게 한다. 요즘 cpu는 레지스터에 할당해서 성능을 개선한다.

문제가 발생하는 지점은 ++이다.
기계어 수준에서는 3단계로 나뉜다.
cpu안의 ALU에서 작업을 하려면 일단 메모리에서 읽어와야한다.
즉 load, add store 단계

![[Pasted image 20230819103910.png]]

즉 ++ 오퍼레이션은 atomic 하지 않으므로 이 문제가 발생한다.

![[Pasted image 20230819104153.png]]
경쟁조건. race condition이 발생한다.

---
2.4 persistence

반대는 휘발성. 
변수라는 것은 메인 메모리 (DRAM)에 들어가게 된다. 폰노이만 머신을 가정
프로그램과 변수는 메인 메모리

cpu와 메모리는 전원 off시 다 사라짐. 아주 특별한 장치는 제외.
계산한 결과가 사라지지 않게 하려면 하드디스크가 필요하다. 이를 통해 영속성을 갖게한다.
쓸때는 어떻게 쓸까? 보통은 파일로 쓴다. 이러한 파일들을 다루기 위해서 file system을 구성해야한다.
왜냐면 하드디스크의 로우레벨을 보면 블록이 모여있다. 사람이 이러한 블록에 접근해서 파일을 다루려면 시스템을 이루고 있어야한다.
![[Pasted image 20230819104902.png]]

영속성 예제.
open, write, close 함수처럼 생긴것이 나오는데 이를 system call이라고 한다.
system call은 운영체제 커널이 제공하는 기능이다.

open이 하는 역할? 
file은 이름, 사람이 알기 쉬운 이름을 갖고 있다. /temp/file에서 보듯 구조화가 되어있다.(트리형태)
트리 구조내에서 경로는 유일.
프로그램 내에서 file은 어떻게 식별할까? integer면 충분하다
사람은 string으로된 path가 필요하지만 프로그램은 integeer면 충분하다
역할? 사람이 알기 쉬운 path로된 파일을 프로세스에서 식별할 수 있는 file descripter로 전환하는 역할을 한다.

종료전에는 fd를 close한다.

파일은 사람은 경로를 통해서, 프로세스는 fd를 통해서 식별한다.
![[Pasted image 20230819105604.png]]

운영체제에서 장치는 파일 인것처럼 추상화한다.

![[Pasted image 20230819105703.png]]


