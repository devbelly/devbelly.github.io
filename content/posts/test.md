---
title: "Test"
date: 2023-09-19T13:32:35+09:00
draft: true
comments: true
toc: true
tags:
  - untagged
---
## Early System

초기에는 컴퓨터에 대한 기대 자체가 크지 않았지만 컴퓨터의 중요성이 점차 커짐에 따라 많은 사람들이 고가의 장비인 컴퓨터를 공유해서 **효율적**으로 사용하고자 했습니다. 따라서 여러 프로세스를 실행할 수 있는 방법들을 생각했는데 그 중 한 가지는 한 프로세스가 I/O를 요청할 때 다른 프로세스를 실행하는 방법이였습니다. 이 방법을 통해 CPU utilization을 개선할 수 있었습니다.

뿐만 아니라 여러 사람들이 컴퓨터에 대해 동시에 접근하니 각자가 실행하는 프로세스에 대해 빠른 응답을 받기를 원했습니다. 따라서 CPU를 나눠 사용하는 시분할 개념이 등장하고 이를 구현한 초기 방법은 한 프로세스를 잠깐 실행하여 실행 중에는 모든 메모리에 대한 엑세스 권한을 부여하고 시간이 끝나면 프로세스를 중지한 후 모든 상태를 디스크에 저장하는 방식이였습니다. 디스크에 저장/복원 하는 과정은 매우 느리기 때문에 디스크에 프로세스를 저장하는 대신 프로세스를 전환하는 동안 메모리에 프로세스를 남겨두어 OS가 시분할을 효과적으로 구현하도록 바뀌었습니다.



다이어그램에는 세 개의 프로세스(A, B, C)가 있으며 각 프로세스는 512KB의 물리적 메모리 중 작은 부분을 할당받습니다. CPU가 하나라고 가정하면 OS는 프로세스 중 하나(예: A)를 실행하도록 선택하고 나머지 프로세스(B 및 C)는 준비 대기열에 앉아 실행을 기다립니다.
시간 공유가 대중화되면서 운영 체제에 대한 새로운 요구가 생겼을 것입니다. 특히 여러 프로그램이 동시에 메모리에 상주할 수 있도록 허용하면 한 프로세스가 다른 프로세스의 메모리를 읽거나 쓰는 것을 원하지 않기 때문에 보호가 중요한 문제가 됩니다.


프로세스에 추가적으로 필요한 것이 주소 변환 정보
Address Space에 존재하는 주소를 VA라고 하는데 프로세스 A,B가 동일하다
물리적으로는 다른 곳에 있어야 하므로 
어디로 갔는지 매핑정보. 

kernel의 어딘가에 프로세스를 위한 주소변환정보가 저장돼있어야한다 8:46

CPU가 다루는 주소는 무엇일가
CPU내부 주소는 VA이다. (왜 va?)
다이렉트로 갈 수 없으므로 변환 정보를 찾아서 (10:48)

결국 물리 메모리로 변환해야한다. 너무 느리면 안되니깐 MMU라는 하드웨어가 담당한다 

VM의 목표
- 투명
- 효율적
	- 코드를 가져올때마다 주소변환.
	- 소프트 웨어적으로 하면 엄청 느리다
	- MMU보다 더 빠르게 하려고 변환 내용을 캐싱한다.
	- 이를 TLB라고 한다.
- 보호 → 
	- 주소 공간은 격리되어야한다.
	- CPU의 user, kernel mode를 통해 가능하다.
		- 주소변환정보를 생성하거나 갱신할 때 사용하는 명령어가 있다.
		- 커널모드에서만 가능
		- 유저모드에서는 만들어진 정보를 사용하기만 할 수 있다.
	- 두번째는 하드웨어를 통해(먼소리)

투명
	복잡한 과정들을 보이지 않게 한다.


